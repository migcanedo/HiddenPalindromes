\documentclass[12pt,letterpaper]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish, es-tabla]{babel}
\usepackage[version=3]{mhchem}
\usepackage[journal=jacs]{chemstyle}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{makeidx}
\usepackage{xcolor}
\usepackage[stable]{footmisc}
\usepackage[section]{placeins}
\usepackage[export]{adjustbox}
%Paquetes necesarios para tablas
\usepackage{longtable}
\usepackage{array}
\usepackage{xtab}
\usepackage{multirow}
\usepackage{colortab}
%Paquete para el manejo de las unidades
\usepackage{siunitx}
\sisetup{mode=text, output-decimal-marker = {,}, per-mode = symbol, qualifier-mode = phrase, qualifier-phrase = { de }, list-units = brackets, range-units = brackets, range-phrase = --}
\DeclareSIUnit[number-unit-product = \;] \atmosphere{atm}
\DeclareSIUnit[number-unit-product = \;] \pound{lb}
\DeclareSIUnit[number-unit-product = \;] \inch{"}
\DeclareSIUnit[number-unit-product = \;] \foot{ft}
\DeclareSIUnit[number-unit-product = \;] \yard{yd}
\DeclareSIUnit[number-unit-product = \;] \mile{mi}
\DeclareSIUnit[number-unit-product = \;] \pint{pt}
\DeclareSIUnit[number-unit-product = \;] \quart{qt}
\DeclareSIUnit[number-unit-product = \;] \flounce{fl-oz}
\DeclareSIUnit[number-unit-product = \;] \ounce{oz}
\DeclareSIUnit[number-unit-product = \;] \degreeFahrenheit{\SIUnitSymbolDegree F}
\DeclareSIUnit[number-unit-product = \;] \degreeRankine{\SIUnitSymbolDegree R}
\DeclareSIUnit[number-unit-product = \;] \usgallon{galón}
\DeclareSIUnit[number-unit-product = \;] \uma{uma}
\DeclareSIUnit[number-unit-product = \;] \ppm{ppm}
\DeclareSIUnit[number-unit-product = \;] \eqg{eq-g}
\DeclareSIUnit[number-unit-product = \;] \normal{\eqg\per\liter\of{solución}}
\DeclareSIUnit[number-unit-product = \;] \molal{\mole\per\kilo\gram\of{solvente}}
\usepackage{cancel}
%Paquetes necesarios para imágenes, pies de página, etc.
\usepackage{graphicx}
\usepackage{lmodern}
\usepackage{fancyhdr}
\usepackage[left=3cm,right=3cm,top=3cm,bottom=3cm]{geometry}
%Paquetes para ejemplos de consola
\usepackage{color}
\definecolor{gray97}{gray}{.97}
\definecolor{gray75}{gray}{.75}
\definecolor{gray45}{gray}{.45}

\usepackage{listings}
\lstset{ frame=Ltb,
framerule=0pt,
aboveskip=0.5cm,
framextopmargin=3pt,
framexbottommargin=3pt,
framexleftmargin=0.4cm,
framesep=0pt,
rulesep=.4pt,
backgroundcolor=\color{gray97},
rulesepcolor=\color{black},
%
stringstyle=\ttfamily,
showstringspaces = false,
basicstyle=\small\ttfamily,
commentstyle=\color{gray45},
keywordstyle=\bfseries,
%
numbers=left,
numbersep=15pt,
numberstyle=\tiny,
numberfirstline = false,
breaklines=true,
}

% minimizar fragmentado de listados
\lstnewenvironment{listing}[1][]
{\lstset{#1}\pagebreak[0]}{\pagebreak[0]}

\lstdefinestyle{consola}
{basicstyle=\scriptsize\bf\ttfamily,
backgroundcolor=\color{gray75},
}

\lstdefinestyle{C}
{language=C,
}
%Instrucción para evitar la indentación
%\setlength\parindent{0pt}
%Paquete para incluir la bibliografía
\usepackage[backend=bibtex,style=chem-acs,biblabel=dot]{biblatex}
\addbibresource{references.bib}

%Formato del título de las secciones

\usepackage[explicit]{titlesec}
\usepackage{enumitem}

%Creación del ambiente anexos
\usepackage{float}
\floatstyle{plaintop}
\newfloat{anexo}{thp}{anx}
\floatname{anexo}{Anexo}
\restylefloat{anexo}
\restylefloat{figure}

%Modificación del formato de los captions
\usepackage[margin=10pt,labelfont=bf]{caption}

%Paquete para incluir comentarios
\usepackage{todonotes}

%Paquete para incluir hipervínculos
\usepackage[colorlinks=true, 
            linkcolor = black,
            urlcolor  = black,
            citecolor = black,
            anchorcolor = black, 
            breaklinks=true]{hyperref}

\usepackage{graphicx}
\usepackage{xcolor}

\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}

\titleformat{\section}{}{}{0em}{\LARGE{\textbf{#1}}}
 
\titleformat{\subsection}{}{}{0em}{\large{\textbf{#1}}}

\setlength{\textwidth}{150mm}
\setlength{\textheight}{195mm}
\setlength{\oddsidemargin}{6mm}
\setlength{\evensidemargin}{28mm}
\setlength{\topmargin}{-5mm}

%%%%%%%%%%%%%%%%%%%%%%
%Inicio del documento%
%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\begin{titlepage}
	\vspace*{-0.5in}
    \begin{figure}[h]
    	\includegraphics[width=4cm, left]{logoUSB.png}
    \end{figure}
    \noindent UNIVERSIDAD SIMÓN BOLÍVAR.\\
    \noindent INGENIERÍA DE LA COMPUTACIÓN.\\
    \noindent DEPT.COMPUTACIÓN Y TECNOLOGÍA DE LA INFORMACIÓN.\\
    \noindent CI3825: SISTEMAS DE OPERACIÓN I.\\

    \vspace*{1.8in}
    \begin{center}
      \begin{Huge}
      	\textbf{Proyecto 1: Palíndromos} \\
      \end{Huge}
    \end{center}

\vspace*{2.2in}

      \noindent \textbf{\large PROFESOR: \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad ALUMNOS:} \\ \\
     Carlos Gomez \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad José D. Bracuto D. \quad 13-10173\\ \\
      . \qquad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad Miguel C. Canedo R. \quad 13-10214
      
\end{titlepage}
% -----------------------------------------------------------
% Indice
% -----------------------------------------------------------
\addtocontents{toc}{\hspace{-7.5mm} \Large{\textbf{}}}
\addtocontents{toc}{\hfill \textbf{} \par}

\tableofcontents
\clearpage
%-------------------------------------------------------------------------------------
\section{Introducción}
  En este informe se explicará como nuestro programa determina si existen palíndromos en un árbol de directorios. Un palíndromo es una palabra de tres o más letras que se lee igual al derecho y al revés. El objetivo de este proyecto es la formación de palabras mediante la concatenación de los nombres de una ruta de directorios, que podrían empezar y terminar en cualquier directorio del árbol formado a partir del la ubicación donde el programa es ejecutado. Ademas se explicarán tanto las formas con las que logramos realizar dicho proyecto como las cualidades que tiene el mismo. 

\section{Compilación y ejecución} 
%-------------------------------------------------------------
   Para compilar el programa primero se debe estar en la ubicacion actual del mismo y correr el script ``make".\\
   
\begin{listing}[style=consola, numbers=none]
mike@mikeVirtual:-/Escritorio/LabOperativos/Proyecto1$ make
\end{listing}

   Igualmente para correr el programa programa se deberá correr con ``./main'' seguido de los flags según sea el caso.
   
\begin{listing}[style=consola, numbers=none]
mike@mikeVirtual:.../Proyecto1$ ./main -d <carpeta> -m <altura> -f 
\end{listing}

   Los flags son opcionales y sus funciones son:
\begin{itemize}
\item \textbf{-d $<$carpeta$>$ :} Establece $<$carpeta$>$ como el directorio desde el cual inicia el árbol. Si no se usa éste flag, por defecto el directorio desde el que iniciará sera el directorio en el que se esta ejecutando el programa.
\item \textbf{-m $<$altura$>$ :} Establece $<$altura$>$ como la altura máxima de árbol que se explorará, es decir se restringirá la profundidad del árbol a crear. Si no se usa éste flag, por defecto el programa recorrerá todas las rutas posibles en las que tenga permiso.
\item \textbf{-f :} Establece que se debe incluir los nombres de los archivos en la lectura de los directorios. Si no se usa éste flag el árbol se realizará sin tomar en cuenta los archivos, solo los directorios.
\end{itemize}

\section{Estrategia de creación de procesos}
%-------------------------------------------------------------
   Para la realización de este programa creamos dos procesos. El primer proceso, el ``proceso padre", se va a encargar de detectar los palíndromos en los path que le indique el segundo proceso, el ``proceso hijo".
   Para esto se creó un proceso hijo con la función \textcolor{purple}{fork}\textbf{()} y seguidamente se continuó la ejecución alternando según sea necesario entre los procesos padre e hijo.

\begin{lstlisting}[style=C]
...
pid_t child = fork(); //Se crea el proceso hijo

if (childpid == 0){ // Se ejecuta el proceso hijo
	// proceso de recorrido de directorio
}
else{ // Se ejecuta el proceso padre
	// proceso de busqueda de palindromos
}
\end{lstlisting}
   
\subsection{\large{Proceso hijo}}
   El proceso hijo se encargará del recorrido de los directorios recursivamente mediante la función \textcolor{purple}{recorrer}\textbf{(\textcolor{red}{char}* path, \textcolor{red}{int} profundidad)}, la cual realiza un recorrido de los directorios con permisos validos desde el directorio especificado (path) hasta la profundidad deseada (profundidad), para luego escribir dicha ruta como un \textbf{\textcolor{red}{string}} en el pipe para mandárselo al proceso padre. \textbf{(Para mayor información acerca de la comunicación entre el proceso padre e hijo revise la sección Estrategia de comunicación y sincronización de procesos)}
   
\subsection{\large{Proceso padre}}
   El proceso padre se encargará de la búsqueda de palíndromos en el \textbf{\textcolor{red}{string}} mandado por el hijo. Realizando primero a la eliminación de los separadores (`/') del string para luego proceder con la búsqueda de los palíndromos llamando a la función \textcolor{purple}{subPalindromos}\textbf{(\textcolor{red}{char}* str, \textcolor{red}{char}* palindromos[], \textcolor{red}{int} nPalindromos[])} que detecta y almacena los substrings que sean palindromos del \textbf{\textcolor{red}{string}} ``str'' y retorna la cantidad de palíndromos encontrados.

\section{Estrategia de comunicación y sincronización de procesos}
%-------------------------------------------------------------
   Para lograr una comunicación y sincronización efectiva se decidió utilizar un \textbf{pipe} para ir almacenando en forma de \textcolor{red}{string} los distintos path, el cual cumple la función de comunicar ambos procesos. Ademas estarán operando junto al \textbf{pipe} dos \textbf{semáforos} (\textcolor{purple}{leer} y \textcolor{purple}{escribir}) que servirán para llevar el control del momento cuando el padre debe \textbf{leer} el \textbf{pipe} o el momento cuando el hijo debe \textbf{escribir} en dicho \textbf{pipe}.  El proceso para esto se puede descomponer en tres casos:

\begin{enumerate}
  \item[1.] En el comienzo del programa se nombran los \textbf{semáforos} (\textcolor{purple}{leer} y \textcolor{purple}{escribir}), se crea el \textbf{pipe} y se abren los \textbf{semáforos} antes nombrados, iniciando el \textbf{semáforo} \textcolor{purple}{leer} apagado mientras que \textcolor{purple}{escribir} inicia encendido. Ademas de des-linkearlos del programa principal para que en el momento en el que los procesos cierren dichos \textbf{semáforos}, estos sean destruidos.
\begin{lstlisting}[style=C]
...
sem_t *leer, *escribir; // Se nombran los semaforos para leer y escribir
...
pipe(p)  //Se crea el pipe "p"

// Se abren los semaforos antes nombrados 
leer = sem_open("semL", (O_CREAT|O_EXCL), 1, 0);
escribir = sem_open("semE", (O_CREAT|O_EXCL), 1, 1);

sem_unlink("semL");  //Des-linkeo de semaforos 
sem_unlink("semE");
...
\end{lstlisting}

  \item[2.] Para el caso cuando que se esté ejecutando el proceso hijo, se deberá esperar hasta se pueda escribir en el pipe mediante el \textbf{semáforo} \textcolor{purple}{escribir}, seguidamente se escribe el path en el \textbf{pipe} y por último se cambia el estado del \textbf{semáforo}  \textcolor{purple}{leer} para que el proceso padre pueda leer lo que contenga el \textbf{pipe}.

\clearpage

\begin{lstlisting}[style=C]
...
sem_wait(escribir); // Se espera hasta el momento en el que se pueda escribir en el pipe

write(p[1], path, 100000); // Se escribe en el pipe

sem_post(leer); // Se cambia el semaforo para que el proceso padre pueda leer el pipe
...
\end{lstlisting}

  \item[3.] Para el caso en el que se esté ejecutando el proceso padre, se cierra el lado de escritura del \textbf{pipe} y se espera hasta el momento en el que se pueda leer dicho \textbf{pipe} mediante el \textbf{semáforo} \textcolor{purple}{leer} y finalmente luego de leer lo que contenga el \textbf{pipe}, se vuelve a cambiar el \textbf{semáforo} \textcolor{purple}{escribir} para que el proceso hijo pueda escribir en nuevamente en él.
\begin{lstlisting}[style=C]
...
close(p[1]); // se cierra el pipe

while(read(p[0], path, 100000) > 0){ // Se lee el pipe
	
	sem_wait(leer); // Se espera hasta el momento en el que se pueda leer el pipe

	// proceso de busqueda de palindromos
	
    sem_post(escribir); // Se modifica el semaforo para que se pueda escribir en el pipe

}
...
\end{lstlisting}
\end{enumerate}

\section{Manejo de strings}
%----------------------------------------------------------------------
   Tanto la búsqueda de palíndromos como el manejo de \textcolor{red}{strings} se ubico en un .c aparte llamado \textbf{manejoStrings.c} con su respectivo .h incluido.
   En este se importaron las librerías \textbf{stdlib.h , stdio.h y string.h} para poder utilizar ciertas funciones que facilitarían el manejo de strings.
   En este archivo se puede encontrar las funciones:
   
\subsection{\large{concat}}
   Esta función recibe dos \textcolor{red}{strings} y los concatena agregando un separador `/' entre ellos
   mediante la asignación de memoria y asignaciones directas para luego devolver un \textcolor{red}{string} con dicho resultado. Siendo esta función de suma utilidad al momento de construir los path.
   
\subsection{\large{quitarSeparador}}
	Es un funcion simple a la que se le pasa como argumento un \textcolor{red}{string} y este lo recorre eliminando el separador `/'.

\subsection*{\large{printArray}}
   Función que recibe un arreglo de \textcolor{red}{strings} y un \textcolor{red}{entero} que representa el tamaño de dicho arreglo con la finalidad de imprimir cada elemento separándolos por ',' y liberando el espacio utilizado.

\subsection{\large{esLetra}}
   Esta función se encarga de revisar si un \textcolor{red}{carácter} pasado como parámetro es o no una letra (`a', ... , `z' ó `A', ... , `Z'). 

\subsection{\large{subPalindromos}}
   Finalmente llegamos a la función principal con la que encontramos los palíndromos en el \textcolor{red}{string} suministrado. Esta función trabaja con una matriz ``\textcolor{purple}{tabla[i][j]}'' de dimensiones $n*n$, donde $n$ representa el tamaño del \textcolor{red}{string}. Esta función se divide en tres fases:

\begin{enumerate}
  \item[1.] En la primera fase se detectan los substrings de tamaño 1, es decir, todas las letras por si solas. Por lo que se modifica las posiciones de la  Diagonal Principal de la \textcolor{purple}{tabla} y en el caso de los \textcolor{red}{caracteres} del castellano, como estos ocupan el doble de espacio entonces se modificarían dichos espacios en la \textcolor{purple}{tabla}.

\clearpage

\begin{lstlisting}[style=C]
...
tabla[i][i] = TRUE; // substrings de tamanio 1 (i=j)

if (str[i] == -61) { // caracteres del castellano
	tabla[i][i+1] = TRUE;  // ocupa dos espacios
	tabla[i+1][i] = TRUE;
    }
\end{lstlisting}

  \item[2.] En esta fase se deberá detectar los substrings de tamaño 2 hay dos letras consecutivas iguales (`aa', `bb', `Aa', `bB', `áá', `áÁ', etc.) considerando los mismos como palíndromos. Durante esta etapa se consideraron también los caracteres del \textcolor{red}{castellano} como la mayúsculas y minúsculas.

\begin{lstlisting}[style=C]
// Si hay dos caracteres del castellano entrara en este condicional.
if (str[i] == -61 && str[i] == str[i+2] && (str[i+1] == str[i+3] || (str[i+1] - str[i+3] == 32 || str[i+3] - str[i+1] == 32) ) ) {
	tabla[i][i+3] = TRUE;
	continue;
}

// En caso de que los dos caracteres no sean del castellano y sean iguales, entra en este condicional. 
if ((str[i] != -61 && str[i] == str[i+1]) || (esLetra(str[i]) && (str[i] - str[i+1] == 32 || str[i+1] - str[i] == 32)))
	tabla[i][i+1] = TRUE;
\end{lstlisting}
  \item[3.] Finalmente en esta fase, se trabaja con cada substring de tamaño 3 o mayor. En cada iteración se va verificando cada substring que comience en la posición \textbf{i} y termine en la posición \textbf{j}. Para ello se revisa si \textcolor{purple}{tabla[$i+1$][$j-1$]} está marcada como \textbf{True}, indicando que le substring que va desde la posición \textbf{i+1} hasta la \textbf{j-1} es un palíndromo, y que ademas se cumpla que el carácter en la posición \textbf{i} del string original es igual al carácter en la posición \textbf{j}. Si ambas condiciones se cumplen, significa que el substring que va desde \textbf{i} hasta \textbf{j} es un Palíndromo. Finalmente se procede a marcar como \textbf{True} la posición \textcolor{purple}{tabla[$i$][$j$]} y a verificar si dicho palíndromo ya fue reportado e incluido en el arreglo \textcolor{purple}{palindromos[]} que, en caso de no estar presente, el mismo se agrega al arreglo.
 
\end{enumerate}
\quad Cabe destacar que a lo largo de cada fase explicada previamente se tuvieron en cuenta la aparición de caracteres del \textcolor{red}{castellano} como la letra \textbf{`ñ'} o las \textbf{vocales acentuadas} (las cuales se consideraban diferentes a las vocales sin acento). Además de considerar durante toda la corrida la indiferencia de si una letra era mayúscula o minúscula, ambas era tratadas como iguales (es decir, `e' == `E'), y a su vez de consideraban al \textbf{espacio en blanco} como un carácter más. 
\section{Explicaciones extras}
%-----------------------------------------

   Se podría añadir como una explicación extra, que a pesar de ciertas herramientas que facilitaban el trabajo del recorrido de directorios, como la función \textbf{ftw()}, el equipo decidió implementar de manera propia una función recursiva que se encargara de realizar dicho trabajo. Esta función es \textbf{\textcolor{purple}{recorrer}(\textcolor{red}{char*} path, \textcolor{red}{int} profundidad)}, la cual intenta abrir el directorio indicado por el path, si posee los permisos necesarios, y revisar los archivos y directorios que contenga, para luego entrar en los directorios, con la excepción de los casos especiales \textbf{`` . ''} y \textbf{`` .. ''} los cuales hacen referencia al directorio mismo y al directorio previo, respectivamente. La decisión de implementar dicha función fue con la intención de tener un mejor acercamiento a como deben funcionar los procesos en el entorno de UNIX.

\section{Conclusiones y lecciones aprendidas}
%-----------------------------------------
   Después de haber realizado este proyecto podemos concluir que C es un lenguaje muy completo en el cual se pueden acceder a varios tipos de información de manera relativamente simple, siempre y cuando se tenga una previa investigación y proceso de comprensión adecuado. Pero también es cierto que se debe de estar pendiente y tener constantemente en cuenta como se trabajará y manejaran todos los procesos y apuntadores de memoria puesto que en el peor de los casos un mal manejo de procesos conllevaría a que la computadora se quede pegada y un mal manejo de la memoria conllevaría a eliminar información crucial sin poder luego recuperarla, por eso es que se aconseja entender bien la teoría antes de llevarla a la práctica.

\section{Referencias}
%-----------------------------------------
  \begin{itemize}
    \item \url{http://cs.indstate.edu/~cbasavaraj/cs559/the_c_programming_language_2.pdf}
    \item \url {http://devdocs.io/c/}
    \item \url{http://www.um.es/earlyadopters/actividades/a3/PCD_Activity3_Session1.pdf}
  \end{itemize}	
\end{document}

